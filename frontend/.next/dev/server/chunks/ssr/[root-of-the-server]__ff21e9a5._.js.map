{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///D:/StrikeIQ/frontend/contexts/AuthContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useReducer, useEffect, ReactNode } from 'react';\nimport { DashboardResponse, isAuthRequired, AuthRequiredData, MarketData } from '../types/dashboard';\n\ninterface AuthState {\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: string | null;\n  lastCheck: number;\n  mode: 'NORMAL' | 'AUTH';\n  loginUrl: string | null;\n}\n\ntype AuthAction = \n  | { type: 'AUTH_CHECK_START' }\n  | { type: 'AUTH_CHECK_SUCCESS'; isAuthenticated: boolean }\n  | { type: 'AUTH_CHECK_ERROR'; error: string }\n  | { type: 'AUTH_REQUIRED'; payload: { login_url: string } }\n  | { type: 'AUTH_SUCCESS'; isAuthenticated: true };\n\nconst initialState: AuthState = {\n  isAuthenticated: false,\n  isLoading: true,\n  error: null,\n  lastCheck: Date.now(),\n  mode: 'NORMAL',\n  loginUrl: null,\n};\n\nfunction authReducer(state: AuthState, action: AuthAction): AuthState {\n  switch (action.type) {\n    case 'AUTH_CHECK_START':\n      return { ...state, isLoading: true, error: null };\n    \n    case 'AUTH_CHECK_SUCCESS':\n      return {\n        ...state,\n        isAuthenticated: action.isAuthenticated,\n        isLoading: false,\n        error: null,\n        lastCheck: Date.now(),\n      };\n    \n    case 'AUTH_CHECK_ERROR':\n      return {\n        ...state,\n        isAuthenticated: false,\n        isLoading: false,\n        error: action.error,\n        lastCheck: Date.now(),\n      };\n    \n    case 'AUTH_REQUIRED':\n      return {\n        ...state,\n        isAuthenticated: false,\n        isLoading: false,\n        error: 'Authentication required',\n        lastCheck: Date.now(),\n        mode: 'AUTH',\n        loginUrl: action.payload.login_url,\n      };\n    \n    case 'AUTH_SUCCESS':\n      return {\n        ...state,\n        isAuthenticated: true,\n        isLoading: false,\n        error: null,\n        lastCheck: Date.now(),\n      };\n    \n    default:\n      return state;\n  }\n}\n\ninterface AuthContextType {\n  state: AuthState;\n  dispatch: React.Dispatch<AuthAction>;\n  checkAuth: () => Promise<void>;\n  handleAuthRequired: (authData: AuthRequiredData) => void;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\nexport function AuthProvider({ children }: AuthProviderProps) {\n  const [state, dispatch] = useReducer(authReducer, initialState);\n\n  const checkAuth = async () => {\n    // Always check auth status, regardless of current state\n    dispatch({ type: 'AUTH_CHECK_START' });\n    \n    try {\n      const response = await fetch('/api/v1/market/status');\n      const data = await response.json();\n      \n      console.log('ðŸ” AuthContext: Auth check response:', data);\n      \n      if (data.status === 'auth_required') {\n        dispatch({ type: 'AUTH_REQUIRED', payload: { login_url: data.data.login_url } });\n      } else {\n        dispatch({ type: 'AUTH_CHECK_SUCCESS', isAuthenticated: true });\n      }\n    } catch (error) {\n      console.error('ðŸ” AuthContext: Auth check error:', error);\n      dispatch({ type: 'AUTH_CHECK_ERROR', error: error instanceof Error ? error.message : 'Unknown error' });\n    }\n  };\n\n  const handleAuthRequired = (authData: AuthRequiredData) => {\n    // Prevent redundant setState calls\n    if (!state.isAuthenticated && !state.isLoading) {\n      return; // Already in auth required state\n    }\n    \n    dispatch({ type: 'AUTH_REQUIRED', payload: { login_url: authData.login_url } });\n    // Stop any polling here\n    console.log('Authentication required, stopping polling');\n  };\n\n  // Listen for auth status updates from polling\n  useEffect(() => {\n    console.log('ðŸŽ§ AuthContext: Setting up event listeners');\n    \n    const handleAuthRequired = (event: CustomEvent) => {\n      console.log('ðŸš« AuthContext: Received authRequired event', event.detail);\n      const { login_url } = event.detail;\n      dispatch({ type: 'AUTH_REQUIRED', payload: { login_url } });\n    };\n\n    const handleAuthSuccess = () => {\n      console.log('âœ… AuthContext: Received authSuccess event');\n      dispatch({ type: 'AUTH_SUCCESS', isAuthenticated: true });\n    };\n\n    window.addEventListener('authRequired', handleAuthRequired as EventListener);\n    window.addEventListener('authSuccess', handleAuthSuccess);\n\n    console.log('âœ… AuthContext: Event listeners set up');\n\n    return () => {\n      console.log('ðŸ§¹ AuthContext: Cleaning up event listeners');\n      window.removeEventListener('authRequired', handleAuthRequired as EventListener);\n      window.removeEventListener('authSuccess', handleAuthSuccess);\n    };\n  }, []);\n\n  // Initial auth check on mount\n  useEffect(() => {\n    console.log('ðŸ” AuthContext: Performing initial auth check');\n    checkAuth();\n  }, []);\n\n  // Periodic auth check every 30 seconds\n  useEffect(() => {\n    const interval = setInterval(() => {\n      console.log('ðŸ” AuthContext: Performing periodic auth check');\n      checkAuth();\n    }, 30000); // Check every 30 seconds\n\n    return () => clearInterval(interval);\n  }, []);\n\n  // Check auth when page becomes visible again (user returns to tab)\n  useEffect(() => {\n    const handleVisibilityChange = () => {\n      if (!document.hidden) {\n        console.log('ðŸ” AuthContext: Page became visible, checking auth');\n        checkAuth();\n      }\n    };\n\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    return () => {\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, []);\n\n  const value: AuthContextType = {\n    state,\n    dispatch,\n    checkAuth,\n    handleAuthRequired,\n  };\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["file:///D:/StrikeIQ/frontend/pages/_app.tsx"],"sourcesContent":["import type { AppProps } from 'next/app';\nimport { useEffect } from 'react';\nimport { AuthProvider } from '../contexts/AuthContext';\nimport '../styles/globals.css';\n\nfunction MyApp({ Component, pageProps }: AppProps) {\n  useEffect(() => {\n    // Apply dark mode by default\n    document.documentElement.classList.add('dark');\n    \n    // ï¿½ AUTH EXPIRY LISTENER\n    const handleAuthExpired = () => {\n      console.warn('ðŸ” Auth expired event received - redirecting to /auth')\n      // Clear any stored auth data\n      localStorage.removeItem(\"upstox_auth\")\n      sessionStorage.removeItem(\"upstox_auth\")\n      \n      // Redirect to auth screen\n      window.location.href = \"/auth\"\n    }\n\n    // Add global event listener for auth expiry\n    window.addEventListener(\"auth-expired\", handleAuthExpired)\n    \n    // ï¿½ðŸ” GLOBAL REST CALL INTERCEPTOR FOR AUDIT\n    const originalFetch = window.fetch;\n    window.fetch = async (...args) => {\n      console.log(\"ðŸŒ REST CALL DETECTED:\", args[0]);\n      console.log(\"ðŸŒ REST METHOD:\", args[1]?.method || 'GET');\n      console.log(\"ðŸŒ REST TIMESTAMP:\", new Date().toISOString());\n      \n      const start = performance.now();\n      const response = await originalFetch(...args);\n      const duration = performance.now() - start;\n      \n      console.log(\"ðŸŒ REST STATUS:\", response.status);\n      console.log(\"ðŸŒ REST DURATION:\", `${duration.toFixed(2)}ms`);\n      \n      return response;\n    };\n    \n    // ðŸ” AXIOS INTERCEPTOR (if axios is used)\n    if (typeof window !== 'undefined' && window.axios) {\n      window.axios.interceptors.request.use((config) => {\n        console.log(\"ðŸŒ AXIOS REST CALL:\", config.url);\n        console.log(\"ðŸŒ AXIOS METHOD:\", config.method);\n        return config;\n      });\n    }\n    \n    console.log(\"ðŸ” REST/WINDOW INTERCEPTORS INSTALLED\");\n    \n    // Cleanup on unmount\n    return () => {\n      window.removeEventListener(\"auth-expired\", handleAuthExpired)\n    }\n  }, []);\n\n  return (\n    <AuthProvider>\n      <Component {...pageProps} />\n    </AuthProvider>\n  );\n}\n\nexport default MyApp;\n"],"names":[],"mappings":";;;;;AACA;AACA;;;;;AAGA,SAAS,MAAM,EAAE,SAAS,EAAE,SAAS,EAAY;IAC/C,IAAA,gHAAS,EAAC;QACR,6BAA6B;QAC7B,SAAS,eAAe,CAAC,SAAS,CAAC,GAAG,CAAC;QAEvC,yBAAyB;QACzB,MAAM,oBAAoB;YACxB,QAAQ,IAAI,CAAC;YACb,6BAA6B;YAC7B,aAAa,UAAU,CAAC;YACxB,eAAe,UAAU,CAAC;YAE1B,0BAA0B;YAC1B,OAAO,QAAQ,CAAC,IAAI,GAAG;QACzB;QAEA,4CAA4C;QAC5C,OAAO,gBAAgB,CAAC,gBAAgB;QAExC,6CAA6C;QAC7C,MAAM,gBAAgB,OAAO,KAAK;QAClC,OAAO,KAAK,GAAG,OAAO,GAAG;YACvB,QAAQ,GAAG,CAAC,0BAA0B,IAAI,CAAC,EAAE;YAC7C,QAAQ,GAAG,CAAC,mBAAmB,IAAI,CAAC,EAAE,EAAE,UAAU;YAClD,QAAQ,GAAG,CAAC,sBAAsB,IAAI,OAAO,WAAW;YAExD,MAAM,QAAQ,YAAY,GAAG;YAC7B,MAAM,WAAW,MAAM,iBAAiB;YACxC,MAAM,WAAW,YAAY,GAAG,KAAK;YAErC,QAAQ,GAAG,CAAC,mBAAmB,SAAS,MAAM;YAC9C,QAAQ,GAAG,CAAC,qBAAqB,GAAG,SAAS,OAAO,CAAC,GAAG,EAAE,CAAC;YAE3D,OAAO;QACT;QAEA,0CAA0C;QAC1C;;QAQA,QAAQ,GAAG,CAAC;QAEZ,qBAAqB;QACrB,OAAO;YACL,OAAO,mBAAmB,CAAC,gBAAgB;QAC7C;IACF,GAAG,EAAE;IAEL,qBACE,qKAAC,iIAAY;kBACX,cAAA,qKAAC;YAAW,GAAG,SAAS;;;;;;;;;;;AAG9B;uCAEe"}}]
}